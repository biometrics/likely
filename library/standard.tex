 % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
 % Copyright 2014 Joshua C. Klontz                                           %
 %                                                                           %
 % Licensed under the Apache License, Version 2.0 (the "License");           %
 % you may not use this file except in compliance with the License.          %
 % You may obtain a copy of the License at                                   %
 %                                                                           %
 %     http://www.apache.org/licenses/LICENSE-2.0                            %
 %                                                                           %
 % Unless required by applicable law or agreed to in writing, software       %
 % distributed under the License is distributed on an "AS IS" BASIS,         %
 % WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  %
 % See the License for the specific language governing permissions and       %
 % limitations under the License.                                            %
 % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\documentclass[twoside=false, numbers=noenddot]{scrbook}

% The Likely tokenizer will look for the use of the "likely" environment to
% determine what parts of the document are Likely source code.
\newenvironment{likely}
{ \verbatim }
{ \endverbatim }

\usepackage{booktabs}
\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{makeidx}
\usepackage{scrhack}
\usepackage{tocbibind}
\usepackage{verbatim}

\lstset{basicstyle=\ttfamily,
  showstringspaces=false
}

\makeindex

\newcommand{\noun}[1]{\textsc{#1}}
\newcommand{\cref}[3]{\href{#1}{#2}\cite{#3}}
\newcommand{\fref}[2]{\href{#1}{#2}\footnote{\href{#1}{#1}}}
\newcommand{\awsurl}{https://s3.amazonaws.com/liblikely/}
\newcommand{\githuburl}{https://raw.githubusercontent.com/biometrics/likely/gh-pages/}
\newcommand{\dindex}[1]{\emph{#1}\index{#1}}
\newcommand{\pindex}[1]{#1\index{#1}}
\newcommand{\tindex}[1]{\pindex{\texttt{#1}}}

% Acronyms
\newcommand{\AST}{AST\index{abstract syntax tree (AST)}}
\newcommand{\CTFE}{CTFE\index{compile-time function evaluation (CTFE)}}
\newcommand{\GFM}{GFM\index{GitHub Flavored Markdown (GFM)}}
\newcommand{\JIT}{JIT\index{just-in-time (JIT)}}
\newcommand{\LLVM}{LLVM\index{Low Level Virtual Machine (LLVM)}}

\hyphenation{Java-Script}

\title{The Likely Programming Language \\
       {\large Language Reference and Standard Library}}
\author{Joshua C. Klontz}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\chapter{Introduction}
\fref{http://www.liblikely.org/}{\noun{Likely}} is a programming language for image processing and statistical learning algorithm development.
The following sections discuss the guiding design decisions behind Likely.

\section{Embeddable Compiler}
Likely is foremost a software library.
Both the \fref{\awsurl doxygen/console\_interpreter\_compiler.html}{\texttt{likely} console-interpreter-compiler} and the \fref{\awsurl doxygen/integrated\_development\_environment.html}{\texttt{dream} integrated development environment} are built on top of the \fref{\awsurl doxygen/index.html}{\noun{Likely C API}}.

Understandably, there is more involved in deploying a computer vision application than applying algorithms to pixels alone.
Likely is designed to excel at pixel/feature/subspace transformations, while leaving general application logic for the developer's programming language of choice.
Likely code can both call, and be called by the \cref{http://www.cs.otago.ac.nz/cosc440/readings/C-Programming-Ebook.pdf}{C Programming Language}{kernighan1988c}, and by extension many other programming languages as well.

It was with this focus on an embeddable compiler that the \url{liblikely.org} domain name was chosen.

\section{Compile-Time Function Evaluation}
Compile-time function evaluation (\CTFE) is a core tenant of the Likely programming language.
Likely rejects the learning of a statistical model as an offline step after algorithm compilation.
Instead, \emph{Likely formulates statistical learning as the compile-time evaluation of a function} (the learning algorithm) \emph{with constant arguments} (the training data).

Likely leverages the \cref{http://llvm.org/}{Low Level Virtual Machine}{lattner2004llvm} (\LLVM) project for both static and just-in-time (\JIT) compilation.
One particularly salient use of the \JIT\ compiler is for \CTFE, as the \JIT\ compiler automatically leverages all instruction set extensions and coprocessors available at runtime.
In the special case where the function to be executed does not have loops, Likely will instead run an interpreter, which has been found to be faster for executing simple code.

A computer vision algorithm is a series of image processing and statistical learning transformations requiring incoming samples that conform to particular type and dimensionality expectations.
Likely exploits these expectations through inference on the output of functions evaluated at compile time.
Algorithms written without specifying parameter types are still statically compiled because \emph{\CTFE\ output dictates parameter type, and often array dimensionality as well}.
This is in contrast to conventional computer vision libraries which, lacking compile-time knowledge of the particular algorithm of interest, provide parameter type generality by branching at runtime.
This branching is often unnecessary for any particular algorithm where all runtime samples are expected to follow the same code path.

\section{Portability}
Likely is written in a portable subset of modern C++\cite{stroustrup1986c++}, which means it can \fref{http://llvm.org/docs/GettingStarted.html\#hardware}{run everywhere \LLVM\ does}.
Algorithms execute natively on single CPU threads via the \LLVM\ \noun{Machine Code \JIT} compiler, multi-core CPUs via a custom \noun{OpenMP}-like backend, and GPUs and coprocessors via \noun{CUDA} or \noun{OpenCL} (in progress).

Likely algorithms can be \fref{http://liblikely.org/share/likely/hello\_world/hello\_world\_static.c}{statically compiled to native object files}, \fref{http://liblikely.org/share/likely/hello\_world/hello\_world\_jit.c}{just-in-time compiled for dynamic applications and scripts}, integrated into other languages (in progress), published as web services (in progress), and even transcompiled into single \noun{C} or \noun{JavaScript} source files (in progress).

\section{Live Coding}
Developing computer vision algorithms is a creative process, and like all creative processes it relies on immediate visceral feedback through interaction with the creative medium.
Algorithms have numerous parameters, and visualizing their effects is critical to building intuition and making improvements.
The computer vision domain and Likely's library design are well suited for the idea of \dindex{live coding} popularized by \fref{http://worrydream.com/}{Bret Victor}.
In fact, Likely's accompanying IDE called \emph{dream}, is \fref{https://www.youtube.com/watch?v=a\_hz8wFACVM}{designed from the ground up to support interactive algorithm development}.

\section{Literate Programming}
Likely is a \cref{http://www.literateprogramming.com/}{\pindex{literate programming}}{knuth1984literate} language.
In addition to serving as the reference manual for the programming language and standard library, \fref{\githuburl library/standard.tex}{\emph{this document is also the source code for the Likely standard library}}.

Likely recognizes both \fref{https://help.github.com/articles/github-flavored-markdown}{GitHub Flavored Markdown} (\GFM) and \cref{http://www.latex-project.org/}{\LaTeX \index{LaTeX}}{lamport1986document} syntax, and will automatically extract source code from appropriately marked blocks.

\part{Language Reference}
\chapter{Parsing}
This chapter covers how a source code file is translated into the compiler's \emph{abstract syntax tree} (\AST) program representation.
This is also referred to as the compiler's \fref{\awsurl doxygen/group\_\_frontend.html}{\dindex{frontend}}.

\section{Source Code File Formats}
To facilitate \pindex{literate programming}, Likely recognizes several source code file formats based on their extension:

\begin{figure}[h]
\begin{description}
\item[.lisp] - The entire file is Likely source code.
\item[.md]   - \GFM\ file, source code is extracted from \texttt{likely} syntax-highlighted code blocks.
\item[.tex]  - \pindex{LaTeX} file, source code is extracted from the \texttt{likely} environment.
\end{description}
\caption{Source code file extensions and formats.}
\end{figure}

For example, this \GFM\ \fref{\githuburl library/literate\_programming.md}{source file} can be rendered \fref{http://liblikely.org/?href=literate\_programming}{in a web browser} and also executed by Likely:

\begin{lstlisting}[language=bash, caption={Literate programming using \GFM.}, captionpos=b]
$ likely library/literate_programming.md
42
\end{lstlisting}

Similarly, this \pindex{LaTeX} \fref{\githuburl library/literate\_programming.tex}{source file} can be rendered \fref{\awsurl latex/literate\_programming.pdf}{to \noun{PDF}} and also executed by Likely:

\begin{lstlisting}[language=bash, caption={Literate programming using \pindex{LaTeX}.}, captionpos=b]
$ likely library/literate_programming.tex
42
\end{lstlisting}

\tindex{likely\char`_guess\char`_file\char`_type} is the function call for inferring file format from extension.

\section{Lexical Analysis}
Source code is first converted into a sequence of words or \dindex{tokens} by applying the following rules:

\begin{figure}[h]
\begin{enumerate}
\item Tokens are separated by \pindex{whitespace}.
\item The following special single-character tokens need not be separated by \pindex{whitespace}:\newline
      \texttt{();.:}
\item The characters between double-quotation marks are a single token, including the quotation marks themselves.
\end{enumerate}
\caption{Lexical analysis rules.}
\end{figure}

Where \dindex{whitespace} is defined by the C function \fref{http://www.cplusplus.com/reference/cctype/isspace/}{\texttt{isspace}}.

\tindex{likely\char`_lex} is the function call for lexical analysis.

\section{Prefix Notation}
Likely is a member of the Lisp family of languages, accepting fully-parenthesized Polish \pindex{prefix notation}:

\begin{figure}[h]
\centering
\texttt{($operator$ $operand_1$ $operand_2$ \dots\ $operand_N$)}
\caption{Prefix notation.}
\end{figure}

For example:

\begin{lstlisting}[language=bash, caption={Prefix notation example.}, captionpos=b]
$ likely -c "(+ 1 2)"
3
\end{lstlisting}

An important property of prefix notation is that it is equivalent to the \AST, where a branch is a \dindex{list} and leaf is an \dindex{atom}.
Every branch or leaf is also called an \dindex{expression}.
A reading of \cref{https://mitpress.mit.edu/sicp/full-text/book/book.html}{Structure and Interpretation of Computer Programs}{Abelson:1996:SIC:547755} is strongly encouraged for developers interested in a deeper understanding of the motivations behind this syntax.

\tindex{likely\char`_parse} is the function call for constructing an \AST\ from \pindex{tokens}.

\section{Special Tokens}
Likely recognizes three special \pindex{tokens} that influence how \pindex{expressions} are parsed into an \AST.
These \pindex{tokens} allow developers to selectively depart from \pindex{prefix notation} to improve code readability.

\begin{table}[h]
\centering
\begin{tabular}{@{} l l @{}}
\toprule
Token & Name    \\ \midrule
;     & Comment \\
.     & Compose \\
:     & Infix   \\
\bottomrule
\end{tabular}
\caption{Likely special tokens.}
\end{table}

When in doubt, you can print the \AST\ to see how source code is parsed:
\begin{lstlisting}[language=bash, caption={Printing the abstract syntax tree.}, captionpos=b]
$ likely -ast -c "1 :+ 2"
(+ 1 2)
\end{lstlisting}

\subsection{Comment (;)}
The semicolon and all subsequent \pindex{tokens} through the end of the line are excluded from the \AST.

\begin{verbatim}
(this is some code) ; this is a comment
; (also a comment)
(back to code again)
\end{verbatim}

\subsection{Compose (.)}
The \pindex{expression} to the left-hand-side (LHS) of the period is the first operand of the expression to the right-hand-side (RHS) of the period.
Compose \index{compose} is \emph{left-associative}.

\begin{verbatim}
x.f     ; Parsed as (f x)
x.f.g   ; Parsed as (g (f x))
x.(f y) ; Parsed as (f x y)
(f x).g ; Parsed as (g (f x))
(g x.f) ; Parsed as (g (f x))
7.2     ; Parsed as 7.2
3.sq    ; Evaluates to 9
1.(+ 2) ; Evaluates to 3
\end{verbatim}

We might call the third example \cref{http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394}{uniform function call syntax}{Bright:2012:UFC}.
In the sixth example, note how this transformation does not apply to numbers!

\subsection{Infix (:)}
\label{subsec:infix}
The \pindex{expression} to the RHS of the colon is the operator.
The \pindex{expression} to the LHS of the colon is the first operand.
The second \pindex{expression} to the RHS of the colon is the second operand.
Infix \index{infix} is \emph{right-associative} and has \emph{lower} precedence than \pindex{compose}.

\begin{verbatim}
x:f y       ; Parsed as (f x y)
z:g x:f y   ; Parsed as (g z (f x y))
x:f (g y)   ; Parsed as (f x (g y))
x.f:h y.g   ; Parsed as (h (f x) (g y))
(g x:f y)   ; Parsed as (g (f x y))
1:+ 2       ; Evaluates to 3
3.sq:+ 4.sq ; Evaluates to 25
\end{verbatim}

The \pindex{infix} operator is often used for \pindex{define} statements:
\begin{verbatim}
name := value
\end{verbatim}

and \dindex{object-oriented programming}:
\begin{verbatim}
object:function argument
\end{verbatim}

\section{List Notation (\{ \dots\ \}, [ \dots\ ])}
Likely makes an additional departure from fully parenthesized notation, automatically identifying \dindex{braces} and \dindex{brackets} as \pindex{list} structures.

\begin{verbatim}
{ x y z } ; Parsed as ({ x y z })
[ q ]     ; Parsed as ([ q ])
\end{verbatim}

See subsection \ref{subsec:begin} for the semantics of \pindex{braces}, and subsection \ref{subsec:evaluate} for the semantics of \pindex{brackets}.

\chapter{Literals}
The Likely compiler recognizes the following kinds of fixed, or \dindex{literal}, \pindex{atom}s.

\section{Integer}
An \dindex{integer} is an \pindex{atom} that can be parsed \emph{to completion in base-0} by the C function \fref{http://www.cplusplus.com/reference/cstdlib/strtoll/}{\texttt{strtoll}}.
If the value can be represented without loss as an \texttt{int32\_t} then it is done so, otherwise it is represented as an \texttt{int64\_t}.

\begin{verbatim}
42   ; A decimal integer
-42  ; A decimal integer
0x2a ; A hexadecimal integer
2a   ; Not an integer
\end{verbatim}

\section{Real}
A \dindex{real} is an \pindex{atom} that can be parsed \emph{to completion} by the C function \fref{http://www.cplusplus.com/reference/cstdlib/strtod/}{\texttt{strtod}}.
If the value can be represented without loss as a \texttt{float} then it is done so, otherwise it is represented as a \texttt{double}.

\begin{verbatim}
0.42  ; A real
0.42- ; Not a real
\end{verbatim}

\section{String}
A \dindex{string} is an \pindex{atom} enclosed in double-quotation marks.
Values are represented as \texttt{const char*}.

\begin{verbatim}
"hello world" ; A string
'hello world' ; Not a string
\end{verbatim}

\section{Type}
\label{sec:type}
A \dindex{type} is a keyword indicating how data is represented.
Let's start with a few examples:

\begin{verbatim}
i16  ; 16-bit signed integer scalar
u32  ; 32-bit unsigned integer scalar
f64  ; 64-bit floating-point real scalar
f32C ; 32-bit floating-point real multi-channel vector
u8XY ; 8-bit unsigned integer multi-column multi-row matrix
\end{verbatim}

In general, a \pindex{type} conforms to the following regular expression:

\begin{figure}[h]
\centering
\texttt{[uif]\char`\\ d+P?S?C?X?Y?T?}
\caption{Regular expression for identifying types.}
\end{figure}

The first character indicates the element bit pattern, and is one of:

\begin{figure}[h]
\begin{description}
\item[u] - Unsigned integer
\item[i] - Signed integer
\item[f] - Floating-point real
\end{description}
\caption{Type leading character.}
\end{figure}

The next one-or-more decimal characters indicate the element bit depth, and should generally be a power of two.
The remaining capitalized characters indicate:

\begin{figure}[h]
\begin{description}
\item[P] - Type is a pointer
\item[S] - Perform saturated arithmetic
\item[C] - Multi-channel matrix
\item[X] - Multi-column matrix
\item[Y] - Multi-row matrix
\item[T] - Multi-frame matrix
\end{description}
\caption{Type trailing characters.}
\end{figure}

The presence or absense of \texttt{C}, \texttt{X}, \texttt{Y} and \texttt{T} indicate whether we call it a \dindex{scalar}, \dindex{vector} or \dindex{matrix} \pindex{type}.

\tindex{likely\char`_type\char`_from\char`_string} is the formal definition of a \pindex{type}.
In addition to accepting the general pattern mentioned above, this function also recognizes a number of special cases corresponding to values in \tindex{likely\char`_type\char`_mask}.
The special cases include all common C types.

\subsection{First-class Citizenship}
An important aspect of a \pindex{type} is that, contrary to most programming languages, it is a \dindex{first-class citizen} of Likely.
It can also be used as a unary-operand to perform a cast and can be \emph{passed as an argument to a function}.

\subsection{Implicit Conversion}
Intrinsic \pindex{operator}s will implictly convert their \pindex{operand}s to the same type.
The rules for doing so are as follows:

\begin{figure}[h]
\begin{enumerate}
\item{If two operands differ in depth, the operand with lesser \pindex{depth} is promoted to the greater \pindex{depth}.}
\item{If one of the operands is an \pindex{integer} and the other is a \pindex{real}, the \pindex{integer} is casted to a \pindex{real}.}
\item{If both operands are integers and one operand is \pindex{signed}, the operation is \pindex{signed}.}
\item{If one operand is \pindex{saturated}, the operation is \pindex{saturated}.}
\end{enumerate}
\caption{Implicit conversion rules.}
\end{figure}

These rules are codified in the function \tindex{likely\char`_type\char`_from\char`_types}.

\subsection{Integer Representation}
Every \pindex{type} is represented by an integer value, codified in the Likely API by \tindex{likely\char`_type}.
This facilitates the construction of functions on types, expressing how the output type of an operation varies with resepect to the input types.

\section{File-type}
If a \pindex{type} indicates how to interpret the contents of an address in memory, a \dindex{file-type} indicates how to interpret the contents of a file on disk.
This is a relatively unimportant portion of the language, and is generally transparent to the developer.
Therefore it is just noted that, analogous to a \pindex{type}, a \pindex{file-type} is defined by the function \tindex{likely\char`_file\char`_type\char`_from\char`_string}, and has an integer value represented in the API by \tindex{likely\char`_file\char`_type}.

\chapter{Intrinsic Operators}
An \dindex{intrinsic operator} is the basic construct for higher order expressions on \pindex{literal}s.
Unless otherwise noted, the choice of symbols and their definitions are consistent with C.
Likely has the following builtin operators.

\section{Arithmetic}
\subsection{(+ \emph{a b})}
The \dindex{addition} of \emph{a} and \emph{b}.

\begin{verbatim}
(+ 2 2)     ; Evaluates to 4
(+ 1.8 2)   ; Evaluates to 3.8
(+ 1.8 2.2) ; Evaluates to 4.0
\end{verbatim}

\subsection{(- \emph{lhs [rhs]})}
If \emph{rhs} is provided then the \dindex{subtraction} of \emph{lhs} by \emph{rhs}, otherwise the \dindex{negation} of \emph{lhs}.

\begin{verbatim}
(- 3 2)     ; Evaluates to 1
(- 2 3)     ; Evaluates to -1
(- 3.2 2)   ; Evaluates to 1.2
(- 3.2 2.2) ; Evaluates to 1.0
(- 1)       ; Evaluates to -1
(- -1.1)    ; Evaluates to 1.1
\end{verbatim}

\subsection{(* \emph{a b})}
The \dindex{multiplication} of \emph{a} and \emph{b}.

\begin{verbatim}
(* 1 2)     ; Evaluates to 2
(* 1.3 2)   ; Evaluates to 2.6
(* 1.5 2.0) ; Evaluates to 3.0
\end{verbatim}

\subsection{(/ \emph{num denom})}
The \dindex{division} of \emph{num} by \emph{denom}.

\begin{verbatim}
(/ 4 2)     ; Evaluates to 2
(/ 4.5 2)   ; Evaluates to 2.25
(/ 4.2 2.1) ; Evaluates to 2.0
\end{verbatim}

\subsection{(\% \emph{num denom})}
The \dindex{remainder} after division of \emph{num} by \emph{denom}.

\begin{verbatim}
(% 7 3)      ; Evaluates to 1
(% 6 3)      ; Evaluates to 0
(% 6 3.0)    ; Evaluates to 0.0
(% 6.5 3)    ; Evaluates to 0.5
(% -6.5 3)   ; Evaluates to -0.5
(% 6.5 -3)   ; Evaluates to 0.5
(% -6.5 -3)  ; Evaluates to -0.5
(% 6.5 7.5)  ; Evaluates to 6.5
(% 6.5 3.25) ; Evaluates to 0.0
\end{verbatim}

\section{Comparison}
The output of these operators is always a 1-bit unsigned \pindex{integer}.

\subsection{(== \emph{a b})}
\texttt{1} if \emph{a} is \dindex{equal-to} \emph{b}, \texttt{0} otherwise.

\begin{verbatim}
(== 2 2)   ; Evaluates to 1
(== 2 2.0) ; Evaluates to 1
(== 2 -2)  ; Evaluates to 0
(== 2 2.1) ; Evaluates to 0
\end{verbatim}

\subsection{(!= \emph{a b})}
\texttt{1} if \emph{a} is \pindex{not} \pindex{equal-to} to \emph{b}, \texttt{0} otherwise.

\begin{verbatim}
(!= 3 3)   ; Evaluates to 0
(!= 3 3.0) ; Evaluates to 0
(!= 3 -3)  ; Evaluates to 1
(!= 3 3.1) ; Evaluates to 1
\end{verbatim}

\subsection{(< \emph{lhs rhs})}
\texttt{1} if \emph{lhs} is \dindex{less-than} \emph{rhs}, \texttt{0} otherwise.

\begin{verbatim}
(< 4 5)    ; Evaluates to 1
(< 4 -5.0) ; Evaluates to 0
(< 4 4.0)  ; Evaluates to 0
\end{verbatim}

\subsection{(<= \emph{lhs rhs})}
\texttt{1} if \emph{lhs} is \pindex{less-than} or \pindex{equal-to} \emph{rhs}, \texttt{0} otherwise.

\begin{verbatim}
(<= 4 5)    ; Evaluates to 1
(<= 4 -5.0) ; Evaluates to 0
(<= 4 4.0)  ; Evaluates to 1
\end{verbatim}

\subsection{(> \emph{lhs rhs})}
\texttt{1} if \emph{lhs} is \dindex{greater-than} \emph{rhs}, \texttt{0} otherwise.

\begin{verbatim}
(> 6 7)    ; Evaluates to 0
(> 6 -7.0) ; Evaluates to 1
(> 6 6.0)  ; Evaluates to 0
\end{verbatim}

\subsection{(>= \emph{lhs rhs})}
\texttt{1} if \emph{lhs} is \pindex{greater-than} or \pindex{equal-to} \emph{rhs}, \texttt{0} otherwise.

\begin{verbatim}
(>= 6 7)    ; Evaluates to 0
(>= 6 -7.0) ; Evaluates to 1
(>= 6 6.0)  ; Evaluates to 1
\end{verbatim}

\section{Logic}
\subsection{(\&\&\ \emph{a b ... n})}
The \dindex{short-circuit} \dindex{logical-and} of \emph{a b ... n}.

\begin{verbatim}
(&& 0 0) ; Short-circuit evaluates to 0
(&& 0 1) ; Short-circuit evaluates to 0
(&& 1 0) ; Evaluates to 0
(&& 1 1) ; Evaluates to 1
\end{verbatim}

\subsection{(\textbar\textbar\ \emph{a b ... n})}
The \dindex{short-circuit} \dindex{logical-or} of \emph{a b ... n}.

\begin{verbatim}
(|| 0 0) ; Evaluates to 0
(|| 0 1) ; Evaluates to 1
(|| 1 0) ; Short-circuit evaluates to 1
(|| 1 1) ; Short-circuit evaluates to 1
\end{verbatim}

\section{Bit Manipulation}
\subsection{(\textasciitilde\ \emph{a})}
The \dindex{bitwise-not} of \emph{a}.

\begin{verbatim}
(~ 0)          ; Evaluates to 2147483647
(~ 2147483647) ; Evaluates to 0
\end{verbatim}

\subsection{(\& \emph{a b})}
The \dindex{bitwise-and} of \emph{a} and \emph{b}.

\begin{verbatim}
(& 1 2) ; Evaluates to 0
(& 1 3) ; Evaluates to 1
\end{verbatim}

\subsection{(\textbar\ \emph{a b})}
The \dindex{bitwise-or} of \emph{a} and \emph{b}.

\begin{verbatim}
(| 1 2) ; Evaluates to 3
(| 1 3) ; Evaluates to 3
\end{verbatim}

\subsection{(\textasciicircum\ \emph{a b})}
The \dindex{bitwise-exclusive-or} of \emph{a} and \emph{b}.

\begin{verbatim}
(^ 1 2) ; Evaluates to 3
(^ 1 3) ; Evaluates to 2
\end{verbatim}

\subsection{(<< \emph{x n})}
The \dindex{left-shift} of \emph{x} by \emph{n} bits.

\begin{verbatim}
(<< 2 0) ; Evaluates to 2
(<< 2 1) ; Evaluates to 4
\end{verbatim}

\subsection{(>> \emph{x n})}
The \dindex{right-shift} of \emph{x} by \emph{n} bits.
If \emph{x} is signed then the operation is an \dindex{arithmetic} right-shift (sign extension), otherwise it is a \dindex{logical} right-shift (zero extension).

\begin{verbatim}
(>> 2 0)  ; Evaluates to 2
(>> 2 1)  ; Evaluates to 1
(>> 2 2)  ; Evaluates to 0
(>> -2 0) ; Evaluates to -2
(>> -2 1) ; Evaluates to -1
\end{verbatim}

\section{Math}
A subset of the \fref{http://www.cplusplus.com/reference/cmath/}{C common mathematical operations}.
The output of these operators is always a \pindex{real}.

\subsection{(sqrt \emph{x})}
The \dindex{square root} of \emph{x}.

\begin{verbatim}
(sqrt 2.0) ; Evaluates to 1.41421
(sqrt 4)   ; Evaluates to 2.0
(sqrt 0)   ; Evaluates to 0.0
\end{verbatim}

\subsection{(sin \emph{x})}
The \dindex{sine} of an angle of \emph{x} radians.

\begin{verbatim}
(sin 0)         ; Evaluates to 0.0
(sin 1.570796)  ; Evaluates to 1.0
(sin -1.570796) ; Evaluates to -1.0
(sin 0.523599)  ; Evaluates to 0.5
\end{verbatim}

\subsection{(cos \emph{x})}
The \dindex{cosine} of an angle of \emph{x} radians.

\begin{verbatim}
(cos 0)        ; Evaluates to 1.0
(cos 3.141593) ; Evaluates to -1.0
(cos 1.047198) ; Evaluates to 0.5
\end{verbatim}

\subsection{(pow \emph{base exponent})}
The \emph{base} raised to the \dindex{power} \emph{exponent}.

\begin{verbatim}
(pow 2 3)     ; Evaluates to 8.0
(pow 2 -3)    ; Evaluates to 0.125
(pow -2 3)    ; Evaluates to -8.0
(pow 1.5 0.5) ; Evaluates to 1.22474
(pow 2 0.5)   ; Evaluates to 1.41421
(pow 4 0.5)   ; Evaluates to 2.0
(pow 4 0)     ; Evaluates to 1.0
\end{verbatim}

\subsection{(exp \emph{x})}
The \dindex{base-e exponential} function of \emph{x}, which is \emph{e} raised to the \pindex{power} \emph{x}.

\begin{verbatim}
(exp 0)   ; Evaluates to 1.0
(exp 1)   ; Evaluates to 2.71828
(exp 1.5) ; Evaluates to 4.48169
\end{verbatim}

\subsection{(exp2 \emph{x})}
The \dindex{base-2 exponential} function of \emph{x}, which is \emph{2} raised to the \pindex{power} \emph{x}.

\begin{verbatim}
(exp2 0)   ; Evaluates to 1.0
(exp2 1)   ; Evaluates to 2.0
(exp2 0.5) ; Evaluates to 1.41421
(exp2 3)   ; Evaluates to 8.0
\end{verbatim}

\subsection{(log \emph{x})}
The \dindex{natural logarithm} (base-e) of \emph{x}.

\begin{verbatim}
(log 1)        ; Evaluates to 0.0
(log 2.718281) ; Evaluates to 1.0
(log 7.389056) ; Evaluates to 2.0
(log 0.5)      ; Evaluates to -0.693147
\end{verbatim}

\subsection{(log10 \emph{x})}
The \dindex{common logarithm} (base-10) of \emph{x}.

\begin{verbatim}
(log10 1)   ; Evaluates to 0.0
(log10 10)  ; Evaluates to 1.0
(log10 100) ; Evaluates to 2.0
(log10 0.5) ; Evaluates to -0.30103
\end{verbatim}

\subsection{(log2 \emph{x})}
The \dindex{binary logarithm} (base-2) of \emph{x}.

\begin{verbatim}
(log2 1)   ; Evaluates to 0.0
(log2 2)   ; Evaluates to 1.0
(log2 4)   ; Evaluates to 2.0
(log2 0.5) ; Evaluates to -1.0
(log2 10)  ; Evaluates to 3.32193
\end{verbatim}

\subsection{(copysign \emph{x y})}
The result of a \dindex{copysign} operation is a value with the magnitude of \emph{x} and the sign of \emph{y}.

\begin{verbatim}
(copysign 3 -1.1) ; Evaluates to -3.0
(copysign -4.3 2) ; Evaluates to 4.3
\end{verbatim}

\subsection{(floor \emph{x})}
The result of a \dindex{floor} operation is the largest integral value that is not greater than \emph{x}.

\begin{verbatim}
(floor 2.3)  ; Evaluates to 2.0
(floor 3.8)  ; Evaluates to 3.0
(floor 5.5)  ; Evaluates to 5.0
(floor -2.3) ; Evaluates to -3.0
(floor -3.8) ; Evaluates to -4.0
(floor -5.5) ; Evaluates to -6.0
\end{verbatim}

\subsection{(ceil \emph{x})}
The result of a \dindex{ceil} operation is the smallest integral value that is not less than \emph{x}.

\begin{verbatim}
(ceil 2.3)  ; Evaluates to 3.0
(ceil 3.8)  ; Evaluates to 4.0
(ceil 5.5)  ; Evaluates to 6.0
(ceil -2.3) ; Evaluates to -2.0
(ceil -3.8) ; Evaluates to -3.0
(ceil -5.5) ; Evaluates to -5.0
\end{verbatim}

\subsection{(trunc \emph{x})}
The result of a \dindex{trunc} operation is the nearest integral value that is not larger in magnitude than \emph{x}.

\begin{verbatim}
(trunc 2.3)  ; Evaluates to 2.0
(trunc 3.8)  ; Evaluates to 3.0
(trunc 5.5)  ; Evaluates to 5.0
(trunc -2.3) ; Evaluates to -2.0
(trunc -3.8) ; Evaluates to -3.0
(trunc -5.5) ; Evaluates to -5.0
\end{verbatim}

\subsection{(round \emph{x})}
The result of a \dindex{round} operation is the integral value that is nearest to \emph{x}, with halfway cases rounded away from zero.

\begin{verbatim}
(round 2.3)  ; Evaluates to 2.0
(round 3.8)  ; Evaluates to 4.0
(round 5.5)  ; Evaluates to 6.0
(round -2.3) ; Evaluates to -2.0
(round -3.8) ; Evaluates to -4.0
(round -5.5) ; Evaluates to -6.0
\end{verbatim}

\section{Statements}
A \dindex{statement} is a value-less expression.

\subsection{(= \emph{name expression})}
The \dindex{define} statement associates a \emph{name} with an \emph{expression}.
A \pindex{define} is \dindex{lazy}, \emph{expression} will only be evaluated if and when \emph{name} is referenced.
Definitions are \dindex{immutable}, though they may \dindex{shadow}.

\begin{verbatim}
x := 1
y := (+ x 1)
x := 4
y      ; Evaluates to 2
(+ x 1); Evaluates to 5
\end{verbatim}

Recall that the colon is the \pindex{infix} token for syntactic sugar described in subsection \ref{subsec:infix}.

\subsection{(\$\ \emph{expression} [\emph{size}])}
The \dindex{allocate} expression stack-allocates a variable with type and initial value of \emph{expression}.
If \emph{size} is provided, the variable is an \dindex{array} instead of a scalar.
Variables are \dindex{mutable} using the \pindex{store} statement.

Because variables is explicitly tied to stack allocation, the \pindex{allocate} expression is not allowed in the global scope.

\begin{verbatim}
{
  x := 1.$
  x ; Evaluates to 1

  y := ($ 3 2)
  (+ (y 0) (y 1)) ; Evaluates to 6
}
\end{verbatim}

\subsection{(<- \emph{name expression} [\emph{index}])}
The \dindex{store} statement stores the value of \emph{expression} into the variable \emph{name} previously defined by an \pindex{allocate} expression.
If \emph{index} is provided, the variable is assumed to be an \pindex{array}, and \emph{expression} is stored at the specified index.

\begin{verbatim}
{
  x := 1.$
  x :<- (+ x 1)
  x ; Evaluates to 2

  y := ($ 0 2)
  (y 0) :<- 1
  (y 1) :<- (+ (y 0) 1)
  (+ (y 0) (y 1)) ; Evaluates to 3
}

\end{verbatim}

\subsection{(assume \emph{expression})}
The \dindex{assume} statement is an optimization hint to the compiler indicating that \emph{expression} is true.

\section{Control Flow}
\subsection{(\{ \emph{statement statement \dots\ statement expression} \})}
\label{subsec:begin}
The \dindex{begin} operator allows imperative-style programming.
Likely will execute a series of zero-or-more \pindex{statement}s, then value of the \pindex{begin} operator is the value of \emph{expression} evaluated in the context of the statements.

As would be expected in an imperative programming language, the open and close braces introduce \dindex{scope} for variable declarations.

\begin{verbatim}
x := 1
y := 2
{
  x := 4
  y := 5
  (+ x y)
} ; Evaluates to 9
(+ x y) ; Evaluates to 3
\end{verbatim}

\subsection{([ \emph{expression} ])}
\label{subsec:evaluate}
The \dindex{evaluate} operator allows compile-time function evaluation.
Likely will execute \emph{expression} at compile-time.

\begin{verbatim}
x := [ (sqrt (+ (* 3 3) (* 4 4))) ] ; x is 5.0
\end{verbatim}

\subsection{(? \emph{condition then [else]})}
The behavior of the \dindex{if} operator depends its use:

\paragraph{(? \emph{condition then else})}
In the case that the \emph{else} operand is provided, the \pindex{if} operator is an \pindex{expression} with value \emph{then} if \emph{condition} is not equal to \texttt{0} and \emph{else} otherwise.
Implicit type conversion ensures that \emph{then} and \emph{else} are the same type.

\begin{verbatim}
x := 1
y := 2
(? (< x y) x y) ; Evaluates to 1
\end{verbatim}

\paragraph{(? \emph{condition then})}
In the case that the \emph{else} operand is not provided, the \pindex{if} operator is a \pindex{statement} with no value.
The \emph{then} \pindex{statement} is executed if and only if \emph{condition} is not equal to \texttt{0}.

\begin{verbatim}
{
  x := 0.$
  (? (== x 0) (<- x 1))
  x
} ; Evaluates to 1
\end{verbatim}

\paragraph{(? \texttt{constant} \emph{then [else]})}
In the case that the condition is a constant \pindex{integer} or \pindex{real}, the branching will happen at compile time.

\begin{verbatim}
x := 0
(? x 1 2) ; Evaluates to 2 at compile time
\end{verbatim}

\subsection{\#}
The \dindex{label} operand refers to the current \dindex{basic block}, or location in the code, that can be jumped to.
This primitive is necessary for constructing loops.

\begin{verbatim}
{
  end := 10
  i := 1.$
  j := 0.$
  loop := #
  (< i end) :?
  {
    j :<- (+ j i)
    i :<- (+ i 1)
    loop
  }
  j
} ; Evaluates to 45
\end{verbatim}

\section{Types}
Recall that \pindex{type} intrinsics were discussed in section \ref{sec:type}.

\subsection{(type \emph{x})}
The \dindex{type} operator returns the intrinsic \pindex{type} of an expression \emph{x}.

\begin{verbatim}
((type 2.0) 1) ; Evaluates to 1.0
\end{verbatim}

\subsection{(make-type \emph{a})}
The \dindex{make-type} operator constructs an intrinsic \pindex{type} from an integer value \emph{a}.

\begin{verbatim}
((make-type 288) 1) ; Evaluates to 1.0
\end{verbatim}

\subsection{(numeric-limit \emph{type smallest non-positive})}
The \dindex{numeric-limit} operator returns the largest or \emph{smallest} positive or \emph{non-positive} value representable by \emph{type}.

\begin{verbatim}
(numeric-limit u8  0 0) ; Evaluates to 255
(numeric-limit u8  0 1) ; Evaluates to 0
(numeric-limit i8  0 0) ; Evaluates to 127
(numeric-limit i8  0 1) ; Evaluates to -128
(numeric-limit u32 0 0) ; Evaluates to 4294967295
(numeric-limit u32 0 1) ; Evaluates to 0
(numeric-limit i32 0 0) ; Evaluates to 2147483647
(numeric-limit i32 0 1) ; Evaluates to -2147483648
(numeric-limit i32 1 0) ; Evaluates to 1
(numeric-limit i32 1 1) ; Evaluates to -1
(numeric-limit f32 0 0) ; Evaluates to 3.40282e+38
(numeric-limit f32 0 1) ; Evaluates to -3.40282e+38
(numeric-limit f32 1 0) ; Evaluates to 1.4013e-45
(numeric-limit f32 1 1) ; Evaluates to -1.4013e-45
\end{verbatim}

\subsection{(pointer \emph{type})}
The \dindex{pointer} operator constructs a new type that is a pointer to an element \emph{type}.
A pointer type can be used as a unary operator, which when given an integer operand, returns the de-referenced value at the speficied index.

\subsection{(struct \emph{name type type \dots\ type})}
The \dindex{struct} operator constructs a new type that is a struct with title \emph{name} and members specified by zero or more \emph{type}.

\section{Matricies}
The fundamental data structure in Likely is a four-dimensional \emph{matrix}.
In decreasing memory spatial locality order, its dimensions are: \emph{channels}, \emph{columns}, \emph{rows} and \emph{frames}.
These dimensions are often abbreviated \emph{c}, \emph{x}, \emph{y} and \emph{t}, respectively.
Ownership of matricies is managed automatically using reference counting.
Matricies are represented with the C API struct \tindex{likely\char`_matrix}.

\subsection{(channels \emph{matrix})}
The \dindex{channels} operator returns the number of \pindex{channels} in \emph{matrix}.

\begin{verbatim}
(channels (read-image "data/misc/lenna.tiff")) ; Evaluates to 3
\end{verbatim}

\subsection{(columns \emph{matrix})}
The \dindex{columns} operator returns the number of \pindex{columns} in \emph{matrix}.

\begin{verbatim}
(columns (read-image "data/misc/lenna.tiff")) ; Evaluates to 512
\end{verbatim}

\subsection{(rows \emph{matrix})}
The \dindex{rows} operator returns the number of \pindex{rows} in \emph{matrix}.

\begin{verbatim}
(rows (read-image "data/misc/lenna.tiff")) ; Evaluates to 512
\end{verbatim}

\subsection{(frames \emph{matrix})}
The \dindex{frames} operator returns the number of \pindex{frames} in \emph{matrix}.

\begin{verbatim}
(frames (read-image "data/misc/lenna.tiff")) ; Evaluates to 1
\end{verbatim}

\subsection{(data \emph{matrix})}
The \dindex{data} operator returns a pointer to the \emph{matrix} \pindex{data}.

This operator is useful for interoperability with external functions that operate on raw data buffers.
Developers generally shouldn't need to use it otherwise in Likely code.

\section{Abstraction}
\subsection{(-> \emph{parameters body})}
The \dindex{lambda} operator returns an anonymous function with the specified list of \emph{parameters} and \emph{body} expression.
In the general case, \emph{parameters} is a \pindex{list} of atoms indicating parameter names and argument order.
As a special case, \emph{parameters} can be a single \pindex{atom} for a unary \pindex{lambda}.

\begin{verbatim}
increment := (-> x (+ x 1))
(increment 1) ; Evaluates to 2
max := (-> (x y) (? (> x y) x y))
(max 2 1) ; Evaluates to 2
two := (-> () 2)
(two) ; Evaluates to 2
\end{verbatim}

\subsection{(=> \emph{arguments body})}
The \dindex{kernel} operator is used to express embarrassingly parallel computations.
Its existence is arguably the primary reason why Likely is a \emph{domain specific} programming language.
The usage of the \pindex{kernel} operator is more complex than other operators, but the benefit is a reduction in boilerplate code for image recognition algorithms.

In the general case, \emph{arguments} is a \pindex{list} of atoms indicating local variables to bring into scope.
As a special case, \emph{arguments} can be a single \pindex{atom} when only one local variable is desired.
The first argument is also the value returned by the \pindex{kernel} operator.

Prior to evaluating the \emph{body} expression, the \pindex{kernel} operator declares four variables: \texttt{c}, \texttt{x}, \texttt{y}, and \texttt{t}, called the \pindex{kernel} \dindex{axes}.
Each of these variables takes on a range of values, from zero to the result of the \emph{\pindex{channels}}, \emph{\pindex{columns}}, \emph{\pindex{rows}} and \emph{\pindex{frames}} operators applied to the first argument, respectively.
The \emph{body} expression is then evaluated for every combination of the \pindex{axes} values in parallel.
As a special case, a \pindex{list} of up to four expressions may be specified before the first argument to manually specify the \pindex{axes} ranges.

Inside a \pindex{kernel} body, every argument becomes an operator taking between zero and four parameters.
These parameters are element indicies if the argument is a matrix, and their default values are the \pindex{axes}.

\subsection{(+> \emph{arguments body})}
The \dindex{reduction} operator is just like the \dindex{kernel} operator in syntax and semantics except for the following differences.
First, reductions are serial instead of parallel.
Second, axes ranges are taken from the second argument instead of the first.

\subsection{(try [ \emph{primary} ] \emph{fallback})}
The \dindex{try} operator returns the \emph{primary} expression if it could be evaluated successfully at compile-time, and the \emph{fallback} expression otherwise.

\begin{verbatim}
(try [ (+ 1 1) ] 3) ; Evaluates to 2
(try [ (+ 1) ] 3)   ; Evaluates to 3
\end{verbatim}

\subsection{(extern \emph{return-type symbol-name parameter-types [lambda]})}
The \dindex{extern} operator returns a callable externally defined function with a C ABI as specified by \emph{return-type}, \emph{symbol-name} and \emph{parameter-types}.
If \emph{lambda} is provided, the \pindex{extern} operator exports the function with the implementation defined by \emph{lambda}.

\begin{verbatim}
((extern int "abs" int) -4) ; Calls the C function with the signature:
                            ;   int abs(int);
                            ; Evaluates to 4

my-abs := (-> x (? (>= x 0) x (- x)))
(extern int "my_abs" int my-abs) ; Callable from C with the signature:
                                 ;   int my_abs(int);
\end{verbatim}

\subsection{import}
The \dindex{import} operator reads and evaluates a source code file.

\part{Standard Library}
\chapter{Basic Symbols}
\section{Constants}
\begin{likely}
true  := 1.bool
false := 0.bool
e  := 2.7182818284590452353602874713526
pi := 3.1415926535897932384626433832795
\end{likely}

\section{Unary Functions}
\begin{likely}
not   := (-> a (== a 0))
sq    := (-> a (* a a))
abs   := (-> a (? (< a 0) (* -1 a) a))
sign  := (-> a (? (< a 0) -1 1))
recip := (-> a (/ 1 a))
++    := (-> a (+ a 1))
--    := (-> a (- a 1))
\end{likely}

\section{Binary Functions}
\begin{likely}
xor := (-> (a b) (!= a.bool b.bool))
min := (-> (a b) (? (< a b) a b))
max := (-> (a b) (? (> a b) a b))

is-positive := (-> a (> a 0))
is-negative := (-> a (< a 0))
\end{likely}

\section{Numeric Limits}
\begin{likely}
numeric-limit-max     := (-> t (numeric-limit t false false))
numeric-limit-min     := (-> t (numeric-limit t false true ))
numeric-limit-epsilon := (-> t (numeric-limit t true  false))
\end{likely}

\chapter{Likely Library Symbols}
\section{Types}
\begin{likely}
string       := i8.pointer
void-pointer := i8.pointer
likely-type      := u32
likely-file-type := u32
\end{likely}

\section{Matrix Information}
\begin{likely}
elements :=
  mat :->
    (* (* (* mat.channels mat.columns) mat.rows) mat.frames)

bytes :=
  mat :->
    (/ (+ (* (& mat.type depth) mat.elements) 7) 8)
\end{likely}

\section{Matrix I/O}
\begin{likely}
read :=
  (file-name file-type return-type) :->
  {
    f := (extern return-type
                 "likely_read"
                 (string likely-file-type likely-type))
    (f file-name file-type return-type)
  }

decode :=
  (mat return-type) :->
  {
    f := (extern return-type
                 "likely_decode"
                 (u8CXYT likely-type))
    (f mat return-type)
  }

write  := (extern bool   "likely_write"  (u8CXYT string))
encode := (extern u8CXYT "likely_encode" (u8CXYT string))
show   := (extern void   "likely_show"   (u8CXYT string))
render := (extern u8CXYT "likely_render" (u8CXYT f64.pointer f64.pointer))

guess-file-type :=
  (extern likely-file-type "likely_guess_file_type" string)

ensure-approximately-equal :=
  (extern void "likely_ensure_approximately_equal" (multi-dimension multi-dimension float))
\end{likely}

\begin{likely}
read-image :=
  (-> file-name (read file-name media     image          ))

read-image-grayscale :=
  (-> file-name (read file-name media     image-grayscale))

read-video :=
  (-> file-name (read file-name media     video          ))

read-video-grayscale :=
  (-> file-name (read file-name media     video-grayscale))

read-directory :=
  (-> file-name (read file-name directory video          ))

read-directory-grayscale :=
  (-> file-name (read file-name directory video-grayscale))

read-matrix :=
  (-> file-name [ (read file-name matrix multi-dimension) ])
\end{likely}

\section{Type Querying}
\begin{likely}
is-type :=
 (t m) :->
   (!= (& t m) 0)

is-floating      := (-> t (is-type t floating     ))
is-pointer       := (-> t (is-type t pointer      ))
is-signed        := (-> t (is-type t signed       ))
is-saturated     := (-> t (is-type t saturated    ))
is-multi-channel := (-> t (is-type t multi-channel))
is-multi-column  := (-> t (is-type t multi-column ))
is-multi-row     := (-> t (is-type t multi-row    ))
is-multi-frame   := (-> t (is-type t multi-frame  ))

is-single-dimension :=
  d :->
   (-> t (== (& t d) 0))

is-single-channel := (is-single-dimension multi-channel)
is-single-column  := (is-single-dimension multi-column )
is-single-row     := (is-single-dimension multi-row    )
is-single-frame   := (is-single-dimension multi-frame  )

type-to-string :=
  (extern i8C "likely_type_to_string" u32)
\end{likely}

\section{Type Conversion}
\begin{likely}
cast :=
  (a b) :->
    (b.type a) ; convert a to the type of b

element-type :=
  x :->
    [((extern u32 "likely_element_type" u32) x.type)].make-type

type-from-types :=
  (t u) :->
    [((extern u32 "likely_type_from_types" (u32 u32)) t u)].make-type

depth-double :=
  t :->
    (| (* (& t depth) 2) (& t (~ depth)))
   .make-type

depth-atleast :=
  (t bits) :->
    (| (max bits (& t depth)) (& t (~ depth)))
   .make-type

depth-atleast-16 := (-> t (depth-atleast t 16))
depth-atleast-32 := (-> t (depth-atleast t 32))
depth-atleast-64 := (-> t (depth-atleast t 64))

not-floating        := (-> t (& t (~ floating       )).make-type)
not-pointer         := (-> t (& t (~ pointer        )).make-type)
not-signed          := (-> t (& t (~ signed         )).make-type)
not-saturated       := (-> t (& t (~ saturated      )).make-type)
not-multi-channel   := (-> t (& t (~ multi-channel  )).make-type)
not-multi-column    := (-> t (& t (~ multi-column   )).make-type)
not-multi-row       := (-> t (& t (~ multi-row      )).make-type)
not-multi-frame     := (-> t (& t (~ multi-frame    )).make-type)
not-multi-dimension := (-> t (& t (~ multi-dimension)).make-type)

imitate-channels   := (-> (t u) (| t.not-multi-channel   (& u multi-channel  )).make-type)
imitate-columns    := (-> (t u) (| t.not-multi-column    (& u multi-column   )).make-type)
imitate-rows       := (-> (t u) (| t.not-multi-row       (& u multi-row      )).make-type)
imitate-frames     := (-> (t u) (| t.not-multi-frame     (& u multi-frame    )).make-type)
imitate-dimensions := (-> (t u) (| t.not-multi-dimension (& u multi-dimension)).make-type)
\end{likely}

\section{Matrix Creation}
\begin{likely}
imitate-size :=
  (mat element-type) :->
    (element-type.(imitate-dimensions mat.type) mat.channels mat.columns mat.rows mat.frames)

imitate :=
  mat :->
    (imitate-size mat mat.type)

copy :=
  src :->
  {
    dst := src.imitate
    (dst src) :=>
      dst :<- src
  }
\end{likely}

\chapter{C Library Symbols}
\section{I/O}
\begin{likely}
puts := (extern int "puts" string)
printf := (extern void "printf" (string ()))
\end{likely}

\chapter{In-place kernels}
\begin{likely}
set :=
  (mat val) :->
    (mat val) :=>
      mat :<- val

set-zero :=
  mat :->
    (set mat 0)

set-identity :=
  mat :->
    mat :=>
      mat :<- (? (== x y) 1 0)

scale :=
  (mat val) :->
    (mat val) :=>
      mat :<- (* mat val)

shift :=
  (mat val) :->
    (mat val) :=>
      mat :<- (+ mat val)

center :=
  (mat val) :->
    (mat val) :=>
      mat :<- (- mat val)
\end{likely}

\chapter{Element-wise operators}
\section{Type Conversion}
\begin{likely}
convert :=
  (mat type) :->
    (set mat.(imitate-size type) mat)
\end{likely}

\section{Thresholding}
\begin{likely}
threshold :=
  (s t hi lo) :->
    (? (> s t) hi lo)

threshold-binary          := (-> (s t hi) (threshold s t hi 0))
threshold-binary-inverse  := (-> (s t lo) (threshold s t 0  lo))
threshold-truncate        := (-> (s t)    (threshold s t t  s))
threshold-to-zero         := (-> (s t)    (threshold s t s  0))
threshold-to-zero-inverse := (-> (s t)    (threshold s t 0  s))
\end{likely}

\section{Rounding}
\begin{likely}
round-integer :=
  (a t) :->
    (t (+ a (? (is-negative a) -0.5 0.5)))
\end{likely}

\section{Color Space Conversion}
\begin{likely}
bgr-to-y-float :=
  (b g r) :->
    (+ (+ (* 0.114.f32 b) (* 0.587.f32 g)) (* 0.299.f32 r))

bgr-to-y-int :=
  (b g r) :->
    (>> (+ (+ (+ (* 1868 b) (* 9617 g)) (* 4899 r)) (<< 1 13)) 14)

bgr-to-y :=
  (t b g r) :->
    ((? t.is-floating bgr-to-y-float bgr-to-y-int) b g r)
\end{likely}

\chapter{Loops}
\section{iter}
\begin{likely}
iter-generic :=
  (expr start end step) :->
  {
    i := start.$
    loop := #
    (!= i end) :?
    {
      (expr i)
      i :<- (step i)
      loop
    }
  }

iter-range :=
  (expr start end) :->
    (iter-generic expr start end (-> i i.++))

iter :=
  (expr end) :->
    (iter-range expr 0 end)

iter-reverse-range :=
  (expr end start) :->
    (iter-generic expr end.-- start.-- (-> i i.--))

iter-reverse :=
  (expr end) :->
    (iter-reverse-range expr end 0)

iter-elements :=
  (mat expr) :->
    (iter (-> i (expr (mat i))) mat.elements)

iter-rectangle :=
  (f x y) :->
    (-> i (-> j (f j i)).(iter x)).(iter y)

iter-square :=
  (f n) :->
    (iter-rectangle f n n)

iter-triangle :=
  (f n) :->
    (-> i (-> j (f j i)).(iter i.++)).(iter n)
\end{likely}

\begin{likely}
while :=
  (expr state) :->
  {
    loop := #
    (state) :?
    {
      (expr)
      loop
    }
  }
\end{likely}

\section{Vector reductions}
\begin{likely}
dot :=
  (a b n) :->
  {
    native-type := (type-from-types (a 0).type (b 0).type).depth-atleast-32
    result := 0.native-type.$
    (-> i (<- result (+ result (* (a i).native-type (b i).native-type)))).(iter n)
    result
  }

norm-l2 :=
  (a n) :->
  {
    native-type := (a 0).type.depth-atleast-32
    result := 0.native-type.$
    add-squared :=
      i :->
        result :<- (+ result (a i).native-type.sq)
    add-squared.(iter n)
    result.sqrt
  }
\end{likely}

\section{Matrix reductions}
\begin{likely}
min-element :=
  src :->
  {
    current-min-value := src.type.numeric-limit-max.$
    check-element :=
      e :->
        current-min-value :<- (min current-min-value e)
    src:iter-elements check-element
    current-min-value
  }

max-element :=
  src :->
  {
    current-max-value := src.type.numeric-limit-min.$
    check-element :=
      e :->
        current-max-value :<- (max current-max-value e)
    src:iter-elements check-element
    current-max-value
  }
\end{likely}

\begin{likely}
average-generic :=
  (avg src n) :->
  {
    avg.set-zero
    (avg src) :+>
      avg :<- (+ avg src)
    (!= n 1) :?
      avg.(scale (avg.element-type n).recip)
    avg
  }

average-channel :=
  src :->
    (average-generic (src.type.depth-atleast-32.floating.not-multi-channel 1 src.columns src.rows src.frames) src src.channels)

average-column :=
  src :->
    (average-generic (src.type.depth-atleast-32.floating.not-multi-column src.channels 1 src.rows src.frames) src src.columns)

average-row :=
  src :->
    (average-generic (src.type.depth-atleast-32.floating.not-multi-row src.channels src.columns 1 src.frames) src src.rows)

average-frame :=
  src :->
    (average-generic (src.type.depth-atleast-32.floating.not-multi-frame src.channels src.columns src.rows 1) src src.frames)
\end{likely}

\section{Matrix Multiplication}
\begin{likely}
transpose :=
  (a) :->
  {
      tr := (a.type a.channels a.rows a.columns a.frames)
      (a tr) :=>
        (tr c y x t) :<- (a c x y t)
      tr
  }

mtimes :=
  (A B) :->
  {
    (assume (== B.rows A.columns))
    C := (A.type 1 B.columns A.rows)
    len := A.columns
    (C A B len) :=>
      C :<- (dot (-> i (A 0 i y))
                 (-> i (B 0 x i))
                 len)
  }

A-transpose-A-generic :=
  (src working-type) :->
  {
    len := src.rows
    dst := (src.type src.channels src.columns src.columns src.frames)
    (dst src len) :=>
    {
      (<= y x) :?
      {
        dot := 0.working-type.$
        (-> i (<- dot (+ dot (* (src c x i t).working-type
                                (src c y i t).working-type)))).(iter len)
        dst         :<- dot
        (dst c y x) :<- dot
      }
    }
  }

A-transpose-A :=
  src :->
    (A-transpose-A-generic src src.element-type.depth-atleast-32)
\end{likely}

\chapter{Sorting}
\section{Selection Sort}
\begin{likely}
selection-sort :=
  (get less-than swap len) :->
  {
    selection-sort-iteration :=
      i :->
      {
        min-element := (get i).$
        min-index   := i.$

        selection-sort-scan :=
          j :->
          {
            element := (get j)
            (less-than element min-element) :?
            {
              min-element :<- element
              min-index   :<- j
            }
          }
        selection-sort-scan.(iter-range i.++ len)

        (!= i min-index) :?
          (swap i min-index)
      }
    selection-sort-iteration.(iter len)
  }
\end{likely}

\bibliographystyle{plain}
\bibliography{library/standard}

\printindex

\end{document}
